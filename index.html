<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <title>Stickman Fighter</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: white;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: manipulation;
    }
    canvas {
      background: #222;
      margin-top: 10px;
      border: 2px solid #444;
      touch-action: none;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin: 10px;
    }
    .button {
      width: 70px;
      height: 70px;
      margin: 5px;
      font-size: 18px;
      border-radius: 10px;
      border: none;
      background: #444;
      color: white;
      touch-action: manipulation;
    }
    .button:active {
      background: #666;
    }
    #status {
      margin-top: 10px;
      font-size: 18px;
      color: lime;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="360" height="480"></canvas>

<div class="controls">
  <button class="button" id="left">‚óÄÔ∏è</button>
  <button class="button" id="right">‚ñ∂Ô∏è</button>
  <button class="button" id="up">‚¨ÜÔ∏è</button>
  <button class="button" id="kick">ü¶µ</button>
  <button class="button" id="punch">üëä</button>
</div>

<div id="status">Waiting for other player...</div>

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const socket = io("https://stick-man-fighter.glitch.me");

  let socketId = null;
  let myPlayer = {
    x: 100, y: 400, vx: 0, vy: 0,
    isPunching: false, isKicking: false,
    color: "lime", jumping: false,
    knockbackVX: 0
  };
  const gravity = 1;
  const jumpStrength = -12;
  const speed = 3;
  const groundY = 400;

  let otherPlayers = {};

  socket.on("init", (data) => {
    socketId = data.id;
    myPlayer.color = data.color;
    updateStatus();
  });

  socket.on("newPlayer", (data) => {
    if (data.id !== socketId) {
      otherPlayers[data.id] = {
        x: 100, y: 400, isPunching: false, isKicking: false,
        color: data.color, knockbackVX: 0
      };
    }
    updateStatus();
  });

  socket.on("position", (data) => {
    if (data.id !== socketId) {
      otherPlayers[data.id] = {
        x: data.x, y: data.y,
        isPunching: data.isPunching,
        isKicking: data.isKicking,
        color: data.color,
        knockbackVX: otherPlayers[data.id]?.knockbackVX || 0
      };
    }
  });

  socket.on("remove", (data) => {
    delete otherPlayers[data.id];
    updateStatus();
  });

  function sendPosition() {
    if (socketId) {
      socket.emit("position", {
        id: socketId,
        x: myPlayer.x,
        y: myPlayer.y,
        isPunching: myPlayer.isPunching,
        isKicking: myPlayer.isKicking,
        color: myPlayer.color
      });
    }
  }

  function drawStickman(x, y, color, isPunching, isKicking) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(x, y - 40, 10, 0, Math.PI * 2); ctx.stroke(); // head
    ctx.beginPath(); ctx.moveTo(x, y - 30); ctx.lineTo(x, y - 10); ctx.stroke(); // body

    if (isPunching) {
      ctx.beginPath(); ctx.moveTo(x, y - 25); ctx.lineTo(x + 15, y - 30); ctx.stroke();
    } else if (isKicking) {
      ctx.beginPath(); ctx.moveTo(x, y - 10); ctx.lineTo(x + 15, y + 10); ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.moveTo(x, y - 25); ctx.lineTo(x + 5, y - 20);
      ctx.moveTo(x, y - 25); ctx.lineTo(x - 5, y - 20);
      ctx.stroke();
    }

    ctx.beginPath();
    ctx.moveTo(x, y - 10); ctx.lineTo(x + 10, y + 10);
    ctx.moveTo(x, y - 10); ctx.lineTo(x - 10, y + 10);
    ctx.stroke();
  }

  function applyKnockback(attacker, target) {
    const dx = target.x - attacker.x;
    if (Math.abs(dx) < 30 && Math.abs(target.y - attacker.y) < 30) {
      const direction = dx > 0 ? 1 : -1;
      target.knockbackVX = direction * 5;
    }
  }

  function handleCombat() {
    for (let id in otherPlayers) {
      const p = otherPlayers[id];
      if (myPlayer.isPunching || myPlayer.isKicking) {
        applyKnockback(myPlayer, p);
      }
    }
  }

  function gameLoop() {
    // Gravity and movement
    myPlayer.x += myPlayer.vx + myPlayer.knockbackVX;
    myPlayer.vy += gravity;
    myPlayer.y += myPlayer.vy;

    // Apply friction to knockback
    myPlayer.knockbackVX *= 0.8;
    if (Math.abs(myPlayer.knockbackVX) < 0.1) myPlayer.knockbackVX = 0;

    // Ground collision
    if (myPlayer.y >= groundY) {
      myPlayer.y = groundY;
      myPlayer.vy = 0;
      myPlayer.jumping = false;
    }

    // Boundaries
    myPlayer.x = Math.max(10, Math.min(canvas.width - 10, myPlayer.x));

    handleCombat();
    sendPosition();

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#333";
    ctx.fillRect(0, groundY + 10, canvas.width, 5);

    drawStickman(myPlayer.x, myPlayer.y, myPlayer.color, myPlayer.isPunching, myPlayer.isKicking);
    for (let id in otherPlayers) {
      const p = otherPlayers[id];
      // Apply knockback to others
      p.x += p.knockbackVX;
      p.knockbackVX *= 0.8;
      if (Math.abs(p.knockbackVX) < 0.1) p.knockbackVX = 0;

      drawStickman(p.x, p.y, p.color, p.isPunching, p.isKicking);
    }

    requestAnimationFrame(gameLoop);
  }

  gameLoop();

  const leftBtn = document.getElementById("left");
  const rightBtn = document.getElementById("right");
  const upBtn = document.getElementById("up");
  const kickBtn = document.getElementById("kick");
  const punchBtn = document.getElementById("punch");

  let moveLeft = false;
  let moveRight = false;

  function updateMovement() {
    myPlayer.vx = moveLeft ? -speed : (moveRight ? speed : 0);
  }

  // Movement
  leftBtn.addEventListener("touchstart", () => { moveLeft = true; updateMovement(); });
  leftBtn.addEventListener("touchend", () => { moveLeft = false; updateMovement(); });
  rightBtn.addEventListener("touchstart", () => { moveRight = true; updateMovement(); });
  rightBtn.addEventListener("touchend", () => { moveRight = false; updateMovement(); });

  // Jump
  upBtn.addEventListener("touchstart", () => {
    if (!myPlayer.jumping) {
      myPlayer.vy = jumpStrength;
      myPlayer.jumping = true;
    }
  });

  // Punch
  punchBtn.addEventListener("touchstart", () => {
    myPlayer.isPunching = true;
    setTimeout(() => { myPlayer.isPunching = false; }, 300);
  });

  // Kick
  kickBtn.addEventListener("touchstart", () => {
    myPlayer.isKicking = true;
    setTimeout(() => { myPlayer.isKicking = false; }, 300);
  });

  function updateStatus() {
    const playerCount = Object.keys(otherPlayers).length + 1;
    document.getElementById("status").textContent =
      playerCount < 2 ? "Waiting for other player..." : "Both players ready!";
  }

  document.addEventListener("touchstart", (e) => {
    if (e.touches.length > 1) e.preventDefault();
  }, { passive: false });

  let lastTouchEnd = 0;
  document.addEventListener("touchend", (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, false);
</script>

</body>
</html>
